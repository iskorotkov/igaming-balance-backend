// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/iskorotkov/igaming-balance-backend/internal/domain"
	"github.com/shopspring/decimal"
)

const balance = `-- name: Balance :one
select balance_id, amount
from balances
where balance_id = $1
`

func (q *Queries) Balance(ctx context.Context, balanceID uuid.UUID) (Balance, error) {
	row := q.db.QueryRow(ctx, balance, balanceID)
	var i Balance
	err := row.Scan(&i.BalanceID, &i.Amount)
	return i, err
}

const deleteTxs = `-- name: DeleteTxs :execrows
update txs
set deleted_at = now()
where balance_id = $1 and tx_id = any($2::uuid[]) and deleted_at is null
`

type DeleteTxsParams struct {
	BalanceID uuid.UUID
	TxIds     []uuid.UUID
}

func (q *Queries) DeleteTxs(ctx context.Context, arg DeleteTxsParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteTxs, arg.BalanceID, arg.TxIds)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const insertTx = `-- name: InsertTx :execrows

insert into txs (balance_id, source, state, amount, tx_id)
values ($1, $2, $3, $4, $5)
`

type InsertTxParams struct {
	BalanceID uuid.UUID
	Source    domain.Source
	State     domain.State
	Amount    decimal.Decimal
	TxID      uuid.UUID
}

// Lock a single balance row.
func (q *Queries) InsertTx(ctx context.Context, arg InsertTxParams) (int64, error) {
	result, err := q.db.Exec(ctx, insertTx,
		arg.BalanceID,
		arg.Source,
		arg.State,
		arg.Amount,
		arg.TxID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const lockBalance = `-- name: LockBalance :execrows
SELECT pg_advisory_xact_lock(hashtext(($1::uuid)::text))
`

func (q *Queries) LockBalance(ctx context.Context, balanceID uuid.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, lockBalance, balanceID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const openBalance = `-- name: OpenBalance :execrows
insert into balances (balance_id, amount)
values ($1, 0)
`

func (q *Queries) OpenBalance(ctx context.Context, balanceID uuid.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, openBalance, balanceID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const previousTxs = `-- name: PreviousTxs :many
select created_at, deleted_at, tx_id, balance_id, source, state, amount
from txs
where balance_id = $1 and tx_id < $2 and (deleted_at is null or $4::bool)
order by tx_id desc
limit $3
`

type PreviousTxsParams struct {
	BalanceID      uuid.UUID
	TxID           uuid.UUID
	Limit          int32
	IncludeDeleted bool
}

func (q *Queries) PreviousTxs(ctx context.Context, arg PreviousTxsParams) ([]Tx, error) {
	rows, err := q.db.Query(ctx, previousTxs,
		arg.BalanceID,
		arg.TxID,
		arg.Limit,
		arg.IncludeDeleted,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tx
	for rows.Next() {
		var i Tx
		if err := rows.Scan(
			&i.CreatedAt,
			&i.DeletedAt,
			&i.TxID,
			&i.BalanceID,
			&i.Source,
			&i.State,
			&i.Amount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const recentTxs = `-- name: RecentTxs :many
select created_at, deleted_at, tx_id, balance_id, source, state, amount
from txs
where balance_id = $1 and (deleted_at is null or $3::bool)
order by tx_id desc
limit $2
`

type RecentTxsParams struct {
	BalanceID      uuid.UUID
	Limit          int32
	IncludeDeleted bool
}

func (q *Queries) RecentTxs(ctx context.Context, arg RecentTxsParams) ([]Tx, error) {
	rows, err := q.db.Query(ctx, recentTxs, arg.BalanceID, arg.Limit, arg.IncludeDeleted)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tx
	for rows.Next() {
		var i Tx
		if err := rows.Scan(
			&i.CreatedAt,
			&i.DeletedAt,
			&i.TxID,
			&i.BalanceID,
			&i.Source,
			&i.State,
			&i.Amount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const txsByID = `-- name: TxsByID :many
select created_at, deleted_at, tx_id, balance_id, source, state, amount
from txs
where balance_id = $1 and tx_id = any($2::uuid[])
`

type TxsByIDParams struct {
	BalanceID uuid.UUID
	TxIds     []uuid.UUID
}

func (q *Queries) TxsByID(ctx context.Context, arg TxsByIDParams) ([]Tx, error) {
	rows, err := q.db.Query(ctx, txsByID, arg.BalanceID, arg.TxIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tx
	for rows.Next() {
		var i Tx
		if err := rows.Scan(
			&i.CreatedAt,
			&i.DeletedAt,
			&i.TxID,
			&i.BalanceID,
			&i.Source,
			&i.State,
			&i.Amount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBalance = `-- name: UpdateBalance :execrows
update balances
set amount = amount + $2
where balance_id = $1
`

type UpdateBalanceParams struct {
	BalanceID uuid.UUID
	Amount    decimal.Decimal
}

func (q *Queries) UpdateBalance(ctx context.Context, arg UpdateBalanceParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateBalance, arg.BalanceID, arg.Amount)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
