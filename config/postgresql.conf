# PostgreSQL 17 Configuration optimized for 1GB RAM system
# Full 1GB available for PostgreSQL server

# Memory Settings
shared_buffers = 256MB                  # Buffer cache for frequently accessed data blocks
effective_cache_size = 768MB            # Total memory available for caching (OS + PG)
work_mem = 8MB                          # Memory per sort/hash operation to avoid disk spills
maintenance_work_mem = 128MB            # Memory for VACUUM, CREATE INDEX, ALTER TABLE operations
wal_buffers = 8MB                       # Buffer for WAL writes before flushing to disk

# Connection Settings
max_connections = 30                    # Limit connections to prevent memory exhaustion
superuser_reserved_connections = 3      # Reserved connections for administrative access

# Checkpoint Settings
checkpoint_completion_target = 0.9      # Spread checkpoint I/O over 90% of checkpoint interval
checkpoint_timeout = 5min               # Maximum time between checkpoints for crash recovery
checkpoint_flush_after = 256kB          # Incremental flushing to reduce I/O spikes
max_wal_size = 1GB                      # Maximum WAL size before forcing checkpoint
min_wal_size = 256MB                    # Minimum WAL files to keep for crash recovery

# PostgreSQL 17 WAL Improvements
wal_buffers = 8MB                       # Larger buffer reduces WAL write frequency
wal_writer_delay = 200ms                # How often WAL writer flushes uncommitted transactions
wal_writer_flush_after = 1MB            # Flush WAL after this amount of data to reduce latency

# Query Planner Settings
random_page_cost = 1.1                  # Cost of non-sequential page access (SSD optimized)
seq_page_cost = 1.0                     # Cost of sequential page access (baseline)
effective_io_concurrency = 200          # Expected concurrent I/O operations for better scheduling
maintenance_io_concurrency = 20         # Concurrent I/O for maintenance operations (VACUUM, etc.)
max_worker_processes = 4                # Total background worker processes available
max_parallel_workers_per_gather = 2     # Max parallel workers per query operation
max_parallel_workers = 4                # System-wide limit for parallel workers
max_parallel_maintenance_workers = 2    # Parallel workers for maintenance operations

# PostgreSQL 17 JIT Settings
jit = on                                # Just-in-time compilation for complex queries
jit_above_cost = 100000                 # Enable JIT only for expensive queries to save memory
jit_inline_above_cost = 500000          # Inline functions only for very expensive queries
jit_optimize_above_cost = 500000        # Full optimization only for very expensive queries

# Logging Configuration
log_destination = 'csvlog'              # Structured CSV format for easier log analysis
logging_collector = on                  # Background process to manage log files
log_directory = 'log'                   # Directory for log files
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'  # Timestamped log files
log_rotation_age = 1d                   # Rotate logs daily to prevent huge files
log_rotation_size = 50MB                # Rotate logs when they exceed this size
log_min_duration_statement = 1000       # Log queries taking longer than 1 second
log_line_prefix = '%t [%p]: [%l-1] user=%u,db=%d,app=%a '  # Detailed log context
log_checkpoints = on                    # Log checkpoint activity for performance monitoring
log_connections = off                   # Disable to reduce log volume and I/O
log_disconnections = off                # Disable to reduce log volume and I/O
log_lock_waits = on                     # Log when queries wait for locks (deadlock detection)
log_temp_files = 0                      # Log all temporary files for performance analysis
log_autovacuum_min_duration = 5000      # Log autovacuum operations longer than 5 seconds

# Runtime Statistics Collection
track_activities = on                   # Track currently executing queries
track_counts = on                       # Track table and index access statistics
track_io_timing = on                    # Track I/O timing for performance analysis
track_functions = pl                    # Track PL/pgSQL function execution statistics
track_wal_io_timing = on                # Track WAL I/O timing for write performance analysis

# Autovacuum Configuration
autovacuum = on                         # Automatic cleanup of dead tuples and table statistics
autovacuum_max_workers = 2              # More workers for faster cleanup on multiple tables
autovacuum_naptime = 30s                # Check interval for autovacuum launcher
autovacuum_vacuum_threshold = 50        # Minimum dead tuples before vacuum
autovacuum_vacuum_scale_factor = 0.15   # Vacuum when 15% of table has dead tuples
autovacuum_analyze_threshold = 50       # Minimum changed tuples before analyze
autovacuum_analyze_scale_factor = 0.075 # Analyze when 7.5% of table has changed
autovacuum_vacuum_insert_threshold = 1000   # Vacuum after many inserts (insert-only tables)
autovacuum_vacuum_insert_scale_factor = 0.2 # Vacuum when 20% of table is new inserts

# Network Settings
listen_addresses = '*'                  # Accept connections from any IP address
port = 5432                             # Standard PostgreSQL port
max_pred_locks_per_transaction = 64     # Memory for predicate locks (serializable isolation)
max_locks_per_transaction = 64          # Memory allocated per transaction for locks

# Locale Settings
datestyle = 'iso, mdy'                  # Date format (ISO standard)
timezone = 'UTC'                        # Use UTC to avoid timezone conversion issues
lc_messages = 'en_US.utf8'              # Language for system messages
lc_monetary = 'en_US.utf8'              # Locale for monetary formatting
lc_numeric = 'en_US.utf8'               # Locale for numeric formatting
lc_time = 'en_US.utf8'                  # Locale for time formatting
default_text_search_config = 'pg_catalog.english'  # Default full-text search dictionary

# Performance Extensions
shared_preload_libraries = 'pg_stat_statements'  # Track query execution statistics

# WAL and Durability Settings
synchronous_commit = on                 # Wait for WAL flush before confirming transaction
wal_sync_method = fdatasync             # Method to force WAL writes to disk
full_page_writes = on                   # Write full pages to WAL after checkpoint
wal_compression = lz4                   # Compress WAL records to save disk space and I/O
wal_init_zero = on                      # Zero-fill new WAL files for better performance
wal_recycle = on                        # Reuse WAL files instead of creating new ones

# Background Writer Configuration
bgwriter_delay = 200ms                  # How often background writer runs
bgwriter_lru_maxpages = 100             # Maximum pages to write per round
bgwriter_lru_multiplier = 2.0           # Multiple of average recent buffer allocations
bgwriter_flush_after = 512kB            # Force OS to flush after writing this amount

# Query Optimizer Configuration
constraint_exclusion = partition        # Use constraints for partition pruning optimization
default_statistics_target = 100         # Sample size for ANALYZE (higher = better estimates)
from_collapse_limit = 8                 # Collapse FROM items into single join
join_collapse_limit = 8                 # Rewrite explicit JOINs into implicit joins
geqo_threshold = 12                     # Use genetic query optimizer for complex joins

# Hash Join Optimization
hash_mem_multiplier = 2.0               # Allow hash tables to use more memory than work_mem
logical_decoding_work_mem = 64MB        # Memory for logical replication decoding

# Vacuum Buffer Usage
vacuum_buffer_usage_limit = 16MB        # Limit vacuum's buffer cache usage to avoid evictions

# I/O Configuration
backend_flush_after = 256kB             # Force OS flush after backends write this amount
checkpoint_flush_after = 256kB          # Incremental checkpoint flushing

# Additional Memory Settings
temp_buffers = 16MB                     # Memory for temporary tables per session
max_stack_depth = 7MB                   # Stack depth limit for complex queries

# Partition-wise Operations
enable_partitionwise_join = on          # Enable joins between matching partitions
enable_partitionwise_aggregate = on     # Enable aggregation within individual partitions

# Parallel Query Cost Settings
parallel_tuple_cost = 0.1               # Cost of transferring tuples between workers
parallel_setup_cost = 1000.0            # Cost of launching parallel workers
min_parallel_table_scan_size = 8MB      # Minimum table size for parallel scan
min_parallel_index_scan_size = 512kB    # Minimum index size for parallel scan
